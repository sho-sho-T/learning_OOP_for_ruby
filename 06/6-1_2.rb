class Bicycle
  attr_reader :style, :size, :tape_color, :front_shock, :rear_shock

  def initialize(args)
    @style = args[:style]
    @size = args[:size]
    @tape_color = args[:tape_color]
    @front_shock = args[:front_shock]
    @rear_shock = args[:rear_shock]
  end

  # "style"の確認は、危険な道へ進む一歩
  def spares
    if style == :road
      { chain: '10-speed', tire_size: '23', tape_color: tape_color }
    else
      { chain: '10-speed', tire_size: '2.1', rear_shock: rear_shock }
    end
  end
end

bike = Bicycle.new(style: :mountain, size: 'S', front_shock: 'Manitou', rear_shock: 'Fox')

# --------------------- オブジェクト指向設計ポイント ------------------------------

# このコードの主な問題点：

# 1. 単一責任の原則違反：
#    Bicycle クラスが複数のタイプの自転車（ロードバイク、マウンテンバイクなど）の
#    振る舞いを1つのクラスで管理している。

# 2. 開放閉鎖の原則違反：
#    新しい自転車のスタイルを追加する度に、spares メソッドを修正する必要がある。
#    これは拡張に対して閉じていない。

# 3. リスコフの置換原則違反：
#    異なるタイプの自転車が同じインターフェースを共有しているが、その振る舞いが
#    大きく異なる。これにより、Bicycle オブジェクトの使用時に予期せぬ動作が
#    発生する可能性がある。

# 4. インターフェース分離の原則違反：
#    全てのタイプの自転車に対して同じインターフェースを強制しており、
#    不要なメソッドや属性が存在する可能性がある。

# 5. 依存性逆転の原則違反：
#    高レベルのモジュール（Bicycle クラス）が低レベルの詳細（具体的な自転車の種類）に
#    直接依存している。

# 6. ポリモーフィズムの欠如：
#    style 属性に基づく条件分岐を使用しており、ポリモーフィズムを活用していない。

# 7. 柔軟性の欠如：
#    自転車の種類や属性が変更された場合、Bicycle クラスの大幅な変更が必要になる。

# 8. コードの重複：
#    異なるスタイルの自転車で共通の属性や振る舞いがある場合、それらが重複して
#    実装される可能性がある。

# 改善のポイント：
# - 基底クラスとして抽象的な Bicycle クラスを作成し、共通の属性とメソッドを定義する。
# - RoadBike, MountainBike などの具体的なサブクラスを作成し、Bicycle クラスを継承させる。
# - spares メソッドを各サブクラスでオーバーライドし、自転車タイプ固有のロジックを実装する。
# - スタイル固有の属性（tape_color, front_shock, rear_shock）を適切なサブクラスに移動する。
# - ファクトリーメソッドまたはファクトリークラスを導入し、適切な自転車オブジェクトの
#   生成を管理する。

# これらの改善により、コードの柔軟性、拡張性、保守性が向上し、
# オブジェクト指向設計の原則に則ったより堅牢な実装となる。

# ---------------------------------------------------------------------------
