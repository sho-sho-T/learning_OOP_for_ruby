class ObscuringReferences
  # attr_reader :wheels はカプセル化を適用しているが、
  # 内部データ構造（Wheelオブジェクトの配列）を完全には隠蔽していない。
  # クラスの利用者が内部表現に依存する可能性がある。
  attr_reader :wheels

  def initialize(data)
    @wheels = wheelify(data)
  end

  def diameters
    wheels.collect do |wheel|
      wheel.rim + (wheel.tire * 2)
    end
  end

  # これで誰でもwheelにrim/tireを送れる
  Wheel = Struct.new(:rim, :tire)
  def wheelify(data)
    data.collect do |cell|
      Wheel.new(cell[0], cell[1])
    end
  end
end

# 使用例
data = [[622, 20], [622, 23], [559, 30]]
obscuring = ObscuringReferences.new(data)
diameters = obscuring.diameters

# --------------------- オブジェクト指向設計ポイント ------------------------------

# このコードの主な特徴と問題点：

# 1. データ構造への依存：
#    初期化時に渡されるデータ構造（配列の配列）に強く依存している。
#    これは、データ表現が変更された場合に、クラス全体の変更が必要になる可能性がある。

# 2. カプセル化の不十分さ：
#    Wheel構造体をクラス内で定義し、attr_readerでwheelsを公開している。
#    これにより、クラスの利用者が内部表現（Wheel構造体）に直接アクセスできてしまう。

# 3. 単一責任の原則の違反：
#    このクラスは、データの変換（wheelify）とビジネスロジック（diameters）の
#    両方を担当している。これらの責任は分離されるべきかもしれない。

# 4. データ変換の隠蔽：
#    wheelifyメソッドでデータ構造の変換を行っているが、この変換ロジックが
#    クラス利用者から隠蔽されている点は良い。ただし、変換後のデータ構造が
#    公開されているため、完全な隠蔽とは言えない。

# 5. 柔軟性の欠如：
#    Wheel構造体の定義がクラス内にハードコードされており、
#    異なる種類の車輪や追加のプロパティに対応するのが困難。

# 6. メソッド名の曖昧さ：
#    'wheelify'という名前は、その機能（配列データからWheelオブジェクトへの変換）を
#    直接的に表現していない。より明確な名前（例：'create_wheels_from_data'）が望ましい。

# 7. 拡張性の問題：
#    新しい計算や操作を追加する場合、このクラスを直接修正する必要がある。
#    これは開放閉鎖の原則に違反する可能性がある。

# 8. テスト困難性：
#    内部データ構造に依存しているため、ユニットテストが複雑になる可能性がある。

# 改善のポイント：
# - データ構造と振る舞いを別々のクラスに分離する。
# - Wheelクラスを独立させ、そのインターフェースを明確に定義する。
# - 初期化時のデータ変換を別のクラスやファクトリーメソッドに移動することを検討する。
# - パブリックインターフェースを最小限に保ち、内部実装の詳細を隠蔽する。
# - より明確で説明的なメソッド名を使用する。

# これらの改善により、コードの保守性、拡張性、再利用性が向上し、
# より堅牢なオブジェクト指向設計になるだろう。

# ---------------------------------------------------------------------------
